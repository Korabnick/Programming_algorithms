"""
Сложность данного кода O(n) поскольку имеет единственный цикл зависящий от задаваемого пользователем значения.
Функция принимает массив с целыми числами, 
Функция возвращает максимальное кол-во денег, которые можно получить с "ограбления".
"""

def bor(nums):
    if not nums: # Если заданный массив пустой, то возвращает 0
        return 0
    if len(nums) == 1: # Если длина массива равна еденице, то функция вернет это самое значение, которое там лежит
        return nums[0]
    if len(nums) == 2: # Если длина массива равна двум, то функция вернет максимальное значение
        return max(nums[0],nums[1])
    def rebbor(nums): # Если ни одно из условий не происходит, то создается переменная now и past равные нулю
        now = past = 0
        for num in nums: #
            now, past = max(now, past + num), now 
        """
        Цикл проходится по массиву и переменной now присваивается максимальное значение между значением 
        переменной now и суммой предыдущего (past) с итерируемым значением, и переменной past присваивается 
        значение переменной now
        """
        return now
    return max(rebbor(nums[1:]),rebbor(nums[:-1]))

print(bor([]))